#!/usr/bin/env ruby
require "bundler/setup"
require "checker"
require 'optparse'
require "ansi"

class CheckTool
  def initialize
    # datadir holds languages.yml and problems.yml
    @datadir = ENV['DATADIR'] || File.expand_path("#{File.dirname(__FILE__)}/../../data")

    # solutiondir holds all solutions
    @solutiondir = ENV['SOLUTIONDIR'] || File.expand_path("#{File.dirname(__FILE__)}/../../solutions")

    @languages = []
    @threads = 4
    @timeout = 1

    # parse command line arguments
    @opts = OptionParser.new do |opt|
      opt.banner =  "Usage: #{opt.program_name} [options] all\n"
      opt.banner =  "       #{opt.program_name} [options] PROBLEM"

      opt.on('--datadir DATADIR', "The location of the directory containing the problems.yml file") do |o|
        @datadir = o
      end

      opt.on('--solutionsdir SOLUTIONSDIR', "The location of the directory containing the solutions") do |o|
        @solutiondir = o
      end

      opt.on('-l LANG', '--language', "Check only solutions in given language (can be given multiple times)") do |o|
        @languages << o
      end

      opt.on('-j NUM', '--threads NUM', "How many worker threads to run to solve the problems (default 4)") do |o|
        @threads = o.to_i
        @threads = 1 if @threads < 1
      end

      opt.on('-t SEC', '--timeout SEC', "Change how many seconds until timeout") do |o|
        @timeout = o.to_f
      end
    end
  end

  # parse command line options
  def parse_opts
    @opts.parse!

    # show help text if no command specified
    if ARGV.empty?
      help @opts
    end
  end

  # prints an error (formatted in red)
  def error(n)
    STDERR.puts ANSI.red {"Error: #{n}"}
    exit(-1)
  end

  # prints a warning (formatted in yellow)
  def warn(n)
    STDOUT.puts ANSI.yellow {"Warning: #{n}"}
  end

  # prints help and quits
  def help(opts)
    puts @opts.help
    exit 0
  end

  # prints info statement
  def info(n)
    STDOUT.puts "#{ANSI.blue{'==>'}} #{n}"
  end

  # prints step statement
  def step(n)
    STDOUT.puts "#{ANSI.green{'==>'}} #{n}"
  end

  def load_problems
    Checker::Problems.load(File.join(@datadir, 'problems.yml'))
  end

  def load_problem(problem_p)
    problems = load_problems

    problem = problems[problem_p.to_i]
    error "Invalid problem specified: #{problem_p}" if !problem.exists?

    problem
  end

  def load_languages
    Checker::Languages.load(File.join(@datadir, 'languages.yml'))
  end

  def load_solutions(problems, languages)
    solutions = Checker::Solutions.new(problems, languages)
    solutions.load_all(@solutiondir)
    solutions
  end

  def check problem_p=nil
    info "Loading problems"
    problems = load_problems

    problem = nil
    if problem_p
      problem = problems[problem_p.to_i]
      error "Invalid problem specified: #{problem_p}" if !problem.exists?
    end

    info "Loading languages"
    languages = load_languages

    info "Loading solutions"
    solutions = load_solutions(problems, languages)

    if problem
      check_single(problem, solutions[problem])
    else
      check_all(problems, solutions)
    end
  end

  def check_all(problems, solutions)
    step "Checking problems with #{@threads} threads"

    ordered_problems = []
    solution_tasks = []
    thread_output = {}
    mutex = Mutex.new
    threads = []

    # fill up our ordered list of problems
    # and the solution tasks for the threads
    solutions.each do |solution|
      if solution.implemented?
        ordered_problems << solution.problem
      end

      # TODO: filter by language
      solution.each do |implementation|
        solution_tasks << implementation
      end
    end

    # find the length of the language with the longest name (pretty outputting)
    languages_len = 0
    solution_tasks.each do |task|
      languages_len = [languages_len, task.lang['name'].length].max
    end

    # start worker threads to run the solvers in the background
    @threads.times do
      threads << Thread.new do
        loop do
          # can't access out or thread_output unless inside a
          # mutex.synchronize block
          out = {}
          task = nil

          mutex.synchronize do
            task = solution_tasks.shift

            # parté when we don't have any tasks left
            Thread.exit unless task

            # make our results accessible
            thread_output[task.problem] ||= {}
            thread_output[task.problem][task.lang['name']] = out

            # set our current task and save the time
            out[:task] = task
            out[:start] = Time.now
          end

          # run task
          res = false
          error = false
          begin
            res = task.check
          rescue Exception => _
            error = true
          end

          # we're done, save time and result so we can
          # move on to the next task
          mutex.synchronize do
            out[:end] = Time.now
            out[:result] = res
            out[:error] = error
          end
        end
      end
    end

    queue_filled = true
    new_problem = true
    while  threads.any?{|thread| thread.alive?} || queue_filled
      queue_filled = false
      sleep 0.1
      cur = nil

      if ordered_problems[0]
        cur_problem = ordered_problems[0]
        queue_filled = true

        mutex.synchronize do
          if thread_output[cur_problem]
            cur = thread_output[cur_problem].dup
          end
        end

        if cur.all?{|lang, task| task[:end]}
          ordered_problems.shift
        end
      end

      if cur
        # TODO
        puts "error" if cur == nil
        time = (cur[:end] || Time.now) - cur[:start]

        result = cur[:result]
        reason = nil

        if(time > @timeout)
          result = false
          reason = 'timeout'
        end

        if cur[:error]
          result = false
          reason = 'error'
        end

        line = result_detail_line(languages_len, cur[:task].lang['name'], time, result, reason)

        if new_problem
          puts line
          new_problem = false unless cur[:end]
        else
          reprint line
          new_problem = true if cur[:end]
        end
      end
    end
  end

  def result_summary_line(languages_len, language, langs)
    # TODO
  end

  def check_single(problem, solution)
    step "Checking problem #{problem.number} with #{@threads} threads"

    threads = []
    tasks = []
    thread_out = []
    output = Mutex.new
    languages_len = 0

    # find all tasks
    solution.each do |impl|
      tasks << impl
    end

    # filter by language
    if @languages.length != 0
      tasks = tasks.keep_if do |task|
        @languages.include?(task.lang['ext']) || @languages.include?(task.lang['name'])
      end
    end

    # find length of languages
    tasks.each do |task|
      languages_len = [languages_len, task.lang['name'].length].max
    end

    # start worker threads to run the solvers in the background
    @threads.times do
      threads << Thread.new do
        loop do
          out = {}
          task = nil

          output.synchronize do
            task = tasks.shift
            Thread.exit unless task
            thread_out << out
            out[:task] = task
            out[:start] = Time.now
          end

          res = false
          error = false
          begin
            res = task.check
          rescue Exception => _
            error = true
          end

          output.synchronize do
            out[:end] = Time.now
            out[:result] = res
            out[:error] = error
          end
        end
      end
    end

    queue_filled = true
    new_task = true
    while  threads.any?{|thread| thread.alive?} || queue_filled
      queue_filled = false
      sleep 0.1
      cur = nil

      output.synchronize do
        if thread_out[0]
          queue_filled = true
          cur = thread_out[0].dup
          thread_out.shift if thread_out[0][:end]
        end
      end

      if cur
        time = (cur[:end] || Time.now) - cur[:start]

        result = cur[:result]
        reason = nil

        if(time > @timeout)
          result = false
          reason = 'timeout'
        end

        if cur[:error]
          result = false
          reason = 'error'
        end

        line = result_detail_line(languages_len, cur[:task].lang['name'], time, result, reason)

        if new_task
          puts line
          new_task = false unless cur[:end]
        else
          reprint line
          new_task = true if cur[:end]
        end
      end
    end
  end

  def result_detail_line(languages_len, language, time, result_r, reason)
    if time < 1
      time = "#{(time*1000).to_i}ms".rjust(6, ' ')
    else
      time = "#{time.round(2)}s".rjust(6, ' ')
    end

    result = {
      true  => ANSI.green{'✔ '},
      false => ANSI.red{'✗ '},
      nil   => '   '}[result_r]

    if reason
      reason = {
        true  => "(#{ANSI.green{reason}}) ",
        false => "(#{ANSI.red{reason}}) ",
        nil   => "(#{reason}) "}[result_r]
    else
      reason = ''
    end

    " #{ANSI.yellow{language.rjust(languages_len, ' ')}} #{time} #{result}#{reason}"
  end

  def reprint s
    print ANSI.cursor_hide
    print ANSI.up(1)
    print ANSI.clear_line
    puts s
    print ANSI.cursor_show
  end
end

tool = CheckTool.new
tool.parse_opts
tool.error "Too many arguments provided." if ARGV.length > 1
if ARGV[0] == 'all'
  tool.check
else
  tool.check ARGV[0]
end

