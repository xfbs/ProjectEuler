#!/usr/bin/env ruby
require "bundler/setup"
require "checker"
require 'optparse'
require "ansi"

class ImplementationTool
  def initialize
    @datadir = ENV['DATADIR'] || File.expand_path("#{File.dirname(__FILE__)}/../../data")
    @problemdir = ENV['PROBLEMDIR'] || File.expand_path("#{File.dirname(__FILE__)}/../../problems")
    @solutiondir = ENV['SOLUTIONDIR'] || File.expand_path("#{File.dirname(__FILE__)}/../../solutions")
    @skeletons = true
    @summary = false

    # parse command line arguments
    @opts = OptionParser.new do |opt|
      opt.banner = "Usage: #{opt.program_name} [options] add PROBLEM LANGUAGE\n#{' '*7}#{opt.program_name} [options] list [PROBLEM]"

      opt.on('--datadir DATADIR', "The location of the directory containing the problems.yml file") do |o| 
        @datadir = o
      end

      opt.on('--problemsdir PROBLEMSDIR', "The location of the directory containing the problems") do |o|
        @problemdir = o
      end

      opt.on('--solutionsdir SOLUTIONSDIR', "The location of the directory containing the solutions") do |o|
        @solutiondir = o
      end

      opt.on('--no-skeletons', "Don't copy over skeleton for language or initialize") do |o|
        @skeletons = false
      end

      opt.on('-s', '--summary', "Only prodide a summary (don't list individual solutions)") do |o|
        @summary = true
      end
    end
  end

  def parse_opts
    @opts.parse!

    # show help text if no command specified
    if ARGV.empty?
      help @opts
    end
  end

  # prints an error (formatted in red)
  def error(n)
    STDERR.puts ANSI.red {"Error: #{n}"}
    exit(-1)
  end

  # prints a warning (formatted in yellow)
  def warn(n)
    STDOUT.puts ANSI.yellow {"Warning: #{n}"}
  end

  # prints help and quits
  def help(opts)
    puts @opts.help
    exit 0
  end

  # prints info statement
  def info(n)
    STDOUT.puts "#{ANSI.blue{'==>'}} #{n}"
  end

  # prints step statement
  def step(n)
    STDOUT.puts "#{ANSI.green{'==>'}} #{n}"
  end

  def add_implementation(problem_p, language_p)
    info "Loading languages"
    languages = Checker::Languages.load(File.join(@datadir, 'languages.yml'))

    language = languages.find do |ext, lang| 
      lang['name'] == language_p || lang['ext'] == language_p
    end
    error "Invalid language specified: #{language_p}" unless language
    language = language[0]

    info "Loading problems"
    problems = Checker::Problems.load(File.join(@datadir, 'problems.yml'))
    problem = problems[problem_p.to_i]
    error "Invalid problem specified: #{problem_p}" unless problem.exists?

    info "Loading solutions"
    solutions = Checker::Solutions.new(problems, languages)
    solutions.load_all(@solutiondir)

    step "Adding #{languages[language]['name']} solution to problem ##{problem.number}"
    error "Solution already exists." if solutions[problem][language]
    begin
      solutions[problem].create_implementation language
    rescue e
      error e.message
    end

    if @skeletons
      info "Copying skeletons to implementation"
      unless solutions[problem][language].create @solutiondir
        error "No skeleton found for language #{languages[language]['name']}"
      end
    else
      warn "Skipping skeletons."
      return
    end
  end

  def list_implementations(problem_p)
    info "Loading languages"
    languages = Checker::Languages.load(File.join(@datadir, 'languages.yml'))

    info "Loading problems"
    problems = Checker::Problems.load(File.join(@datadir, 'problems.yml'))
    problem = problem_p && problems[problem_p.to_i]
    error "Invalid problem specified: #{problem_p}" if problem_p && !problem.exists?

    info "Loading solutions"
    solutions = Checker::Solutions.new(problems, languages)
    solutions.load_all(@solutiondir)

    if problem_p
      step "Solutions for problem #{problem.number.to_s.rjust(3, '0')}: #{problem.name}"

      impls = {}
      solutions[problem].each do |implementation|
        impls[implementation.lang['name']] = implementation.path
      end

      lang_name_len = impls.keys.inject(0){|p,k| [p, k.length].max}

      impls.each do |lang, path|
        puts " #{ANSI.yellow{lang.rjust(lang_name_len, ' ')}} implementation in #{path}"
      end
    else
      step "Listing all known solutions to all problems" unless @summary
      total_langs = {}
      solutions_count = 0
      solutions.each do |solution|
        # keep track of how many solutions there are and how many
        # languages they are written in
        lang_names = []

        # go through the solutions and their implementations and print
        # them out, one by one
        solution.each do |impl|
          lang_name = impl.lang['name']

          # record the frequency of the langs (for the stats later)
          total_langs[lang_name] ||= 0
          total_langs[lang_name] += 1

          # find out which implementations there are for this solution
          lang_names << impl.lang['name']
        end

        # only print a line for this solution if it has at least
        # one implementation
        unless lang_names.empty?
          solutions_count += 1

          unless @summary
            print "Problem #{solution.problem.number.to_s.rjust(3, '0')}: "
            puts lang_names.map{|l| ANSI.yellow{l}}.join(', ')
          end
        end
      end

      total_count = total_langs.values.inject(0, :+)
      info "Total of #{ANSI.green{solutions_count}} solutions, with #{ANSI.green{total_count}} implementations."
      info "Languages: " + total_langs.sort_by{|lang, count| count}.reverse.map{|pair| "#{ANSI.yellow{pair[0]}} (#{ANSI.green{pair[1]}})"}.join(', ')
    end
  end
end

tool = ImplementationTool.new
tool.parse_opts

# figure out what to do
case ARGV[0]
when "add"
  tool.error "No problem specified" unless ARGV[1]
  tool.error "No language specified" unless ARGV[2]
  tool.add_implementation(ARGV[1], ARGV[2])
when "list"
  tool.list_implementations(ARGV[1])
end
