#!/usr/bin/env ruby
require "bundler/setup"
require "checker"
require 'open-uri'
require 'optparse'
require 'nokogiri'
require "ansi"
require 'rdoc'
require 'pry'
require 'pandoc-ruby'
require 'rouge'

class ProblemTool
  def initialize
    # datadir holds languages.yml and problems.yml
    @datadir = ENV['DATADIR'] || File.expand_path("#{File.dirname(__FILE__)}/../../data")

    # problemdir holds all the markdown files for the problems
    @problemdir = ENV['PROBLEMDIR'] || File.expand_path("#{File.dirname(__FILE__)}/../../problems")

    # solutiondir holds all solutions
    @solutiondir = ENV['SOLUTIONDIR'] || File.expand_path("#{File.dirname(__FILE__)}/../../solutions")

    # which editor to use
    @editor = ENV['EDITOR'] || "vim"

    # determine if we do syntax highlighting or not
    @syntax = true

    # parse command line arguments
    @opts = OptionParser.new do |opt|
      opt.banner =  "Usage: #{opt.program_name} [options] [view] PROBLEM\n"
      opt.banner << "       #{opt.program_name} [options] edit PROBLEM\n"
      opt.banner << "       #{opt.program_name} [options] info PROBLEM\n"
      opt.banner << "       #{opt.program_name} [options] move PROBLEM NEW-SLUG\n"

      opt.on('--datadir DATADIR', "The location of the directory containing the problems.yml file") do |o|
        @datadir = o
      end

      opt.on('--problemsdir PROBLEMSDIR', "The location of the directory containing the problems") do |o|
        @problemdir = o
      end

      opt.on('--solutionsdir SOLUTIONSDIR', "The location of the directory containing the solutions") do |o|
        @solutiondir = o
      end

      opt.on('-e EDITOR', '--editor EDITOR', "The editor to use when editing the problem") do |o|
        @editor = o
      end

      opt.on('-s', '--no-syntax', "Don't do syntax highlighting when viewing the problem") do |o|
        @syntax = false
      end
    end
  end

  # parse command line options
  def parse_opts
    @opts.parse!

    # show help text if no command specified
    if ARGV.empty?
      help @opts
    end
  end

  # prints an error (formatted in red)
  def error(n)
    STDERR.puts ANSI.red {"Error: #{n}"}
    exit(-1)
  end

  # prints a warning (formatted in yellow)
  def warn(n)
    STDOUT.puts ANSI.yellow {"Warning: #{n}"}
  end

  # prints help and quits
  def help(opts)
    puts @opts.help
    exit 0
  end

  # prints info statement
  def info(n)
    STDOUT.puts "#{ANSI.blue{'==>'}} #{n}"
  end

  # prints step statement
  def step(n)
    STDOUT.puts "#{ANSI.green{'==>'}} #{n}"
  end

  def load_problems
    Checker::Problems.load(File.join(@datadir, 'problems.yml'))
  end

  def load_problem(problem_p)
    problems = load_problems

    problem = problems[problem_p.to_i]
    error "Invalid problem specified: #{problem_p}" if !problem.exists?

    problem
  end

  def load_languages
    Checker::Languages.load(File.join(@datadir, 'languages.yml'))
  end

  def load_solutions(problems, languages)
    solutions = Checker::Solutions.new(problems, languages)
    solutions.load_all(@solutiondir)
    solutions
  end

  def view problem
    problem = load_problem(problem)

    path = File.join(@problemdir, problem.make_path('md'))
    data = ""

    begin
      file = File.open(path, 'r')
      data = file.read
      file.close
    rescue
      error "Error while reading problem!"
    end

    if @syntax
      formatter = Rouge::Formatters::Terminal256.new
      lexer = Rouge::Lexers::Markdown.new
      print formatter.format(lexer.lex(data))
    else
      puts data
    end
  end

  def edit problem
    problem = load_problem(problem)

    path = File.join(@problemdir, problem.make_path('md'))
    error "Problem file not found: #{path}" unless File.exists? path

    exec(@editor, path)
  end

  def about problem
    info "Loading problem"
    problem = load_problem(problem)

    step "Information about problem #{problem.number.to_s.rjust(3, '0')}"
    path = File.join(@problemdir, problem.make_path('md'))
    puts "     #{ANSI.yellow{'link'}} https://projecteuler.net/problem=#{problem.number}"
    puts "     #{ANSI.yellow{'name'}} #{problem.name}"
    puts "     #{ANSI.yellow{'slug'}} #{problem.slug}"
    puts "     #{ANSI.yellow{'file'}} #{path}"
    puts " #{ANSI.yellow{'solution'}} #{if problem.solution then ANSI.green{'yes'} else ANSI.red{'no'} end}"
  end

  def move problem_p, slug
    info "Loading problems"
    problems = load_problems

    problem = problems[problem_p.to_i]
    error "Invalid problem specified: #{problem_p}" if !problem.exists?

    info "Loading languages"
    languages = load_languages

    info "Loading solutions"
    solutions = load_solutions(problems, languages)

    if problem.slug == slug
      error "New slug is identical with the old one: #{slug}"
    end

    if /[^a-z0-9-]/.match slug
      error "New slug contains illegal characters (can only contain lowercase alphanumeric and dashes)"
    end

    step "Setting slug to #{slug}"
    info "Moving problem file"
    path = File.join(@problemdir, problem.make_path('md'))
    if File.exists? path
      newpath = File.join(@problemdir, Checker::Problem.make_path(problem.number, slug, 'md'))

      begin
        File.rename(path, newpath)
      rescue
        error "Error occured while moving problem file"
      end
    end

    begin
      solutions[problem].move slug
    rescue e
      warn "Error occured while moving solutions: #{e.message}"
    end

    info "Saving updated slug"
    problem.slug = slug
    problems.save
  end
end

tool = ProblemTool.new
tool.parse_opts

if ARGV.length == 1 && ARGV[0].to_i != 0
  ARGV.unshift("view")
end

# figure out what to do
case ARGV[0]
when "view"
  tool.error "No problem specified." unless ARGV[1]
  tool.error "Too many arguments provided." unless ARGV.length == 2
  tool.view(ARGV[1])
when "edit"
  tool.error "No problem specified." unless ARGV[1]
  tool.error "Too many arguments provided." unless ARGV.length == 2
  tool.edit(ARGV[1])
when "info"
  tool.error "No problem specified." unless ARGV[1]
  tool.error "Too many arguments provided." unless ARGV.length == 2
  tool.about(ARGV[1])
when "move"
  tool.error "No problem specified." unless ARGV[1]
  tool.error "No slug specified." unless ARGV[2]
  tool.error "Too many arguments provided." unless ARGV.length == 3
  tool.move(ARGV[1], ARGV[2])
end
