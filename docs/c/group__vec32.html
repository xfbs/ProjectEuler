<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libeuler: vec32</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libeuler
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vec32</div>  </div>
</div><!--header-->
<div class="contents">

<p>data type and functions for handling vectors of <code>uint32_t</code>  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvec32__t.html">vec32_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of uint32_t data type.  <a href="structvec32__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga097a00634a6c3e0ffc940a66cdb4372b"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#ga097a00634a6c3e0ffc940a66cdb4372b">vec32_cmp</a>) (const void *, const void *)</td></tr>
<tr class="memdesc:ga097a00634a6c3e0ffc940a66cdb4372b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison function between two elements.  <a href="#ga097a00634a6c3e0ffc940a66cdb4372b">More...</a><br /></td></tr>
<tr class="separator:ga097a00634a6c3e0ffc940a66cdb4372b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf1a2d7190285201f639b907122247545"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvec32__t.html">vec32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a> (size_t len, uint32_t fill)</td></tr>
<tr class="memdesc:gaf1a2d7190285201f639b907122247545"><td class="mdescLeft">&#160;</td><td class="mdescRight">creates a new <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code>.  <a href="#gaf1a2d7190285201f639b907122247545">More...</a><br /></td></tr>
<tr class="separator:gaf1a2d7190285201f639b907122247545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8105427fa7427284878c0238a1af6a7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#ga8105427fa7427284878c0238a1af6a7b">vec32_alloc</a> (size_t len, uint32_t fill)</td></tr>
<tr class="memdesc:ga8105427fa7427284878c0238a1af6a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">like <code><a class="el" href="group__vec32.html#gaf1a2d7190285201f639b907122247545" title="creates a new vec32_t. ">vec32_new()</a></code>, but allocates with <code>malloc</code>, used to get pointer.  <a href="#ga8105427fa7427284878c0238a1af6a7b">More...</a><br /></td></tr>
<tr class="separator:ga8105427fa7427284878c0238a1af6a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f86a12d44f57c1b5729aebad12dc796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a> (<a class="el" href="structvec32__t.html">vec32_t</a> *v)</td></tr>
<tr class="memdesc:ga3f86a12d44f57c1b5729aebad12dc796"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>free()</code>'s the data held inside a <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code>.  <a href="#ga3f86a12d44f57c1b5729aebad12dc796">More...</a><br /></td></tr>
<tr class="separator:ga3f86a12d44f57c1b5729aebad12dc796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga852aee55c3f73da78fc057a2ec82ffb5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a> (const <a class="el" href="structvec32__t.html">vec32_t</a> *v, size_t pos)</td></tr>
<tr class="memdesc:ga852aee55c3f73da78fc057a2ec82ffb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">gets an element of the <code>uint32_t</code> vector.  <a href="#ga852aee55c3f73da78fc057a2ec82ffb5">More...</a><br /></td></tr>
<tr class="separator:ga852aee55c3f73da78fc057a2ec82ffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b4d78afc51457c7099377c6fbc23052"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#ga3b4d78afc51457c7099377c6fbc23052">vec32_set</a> (<a class="el" href="structvec32__t.html">vec32_t</a> *v, size_t pos, uint32_t data)</td></tr>
<tr class="memdesc:ga3b4d78afc51457c7099377c6fbc23052"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the element at the specified position to <code>data</code>.  <a href="#ga3b4d78afc51457c7099377c6fbc23052">More...</a><br /></td></tr>
<tr class="separator:ga3b4d78afc51457c7099377c6fbc23052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67d98adff29507dd90378dbb912eb4a6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#ga67d98adff29507dd90378dbb912eb4a6">vec32_len</a> (const <a class="el" href="structvec32__t.html">vec32_t</a> *v)</td></tr>
<tr class="memdesc:ga67d98adff29507dd90378dbb912eb4a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the length of a vector.  <a href="#ga67d98adff29507dd90378dbb912eb4a6">More...</a><br /></td></tr>
<tr class="separator:ga67d98adff29507dd90378dbb912eb4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf637a5dd4fc2d47514b6cdd1b9341c82"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a> (<a class="el" href="structvec32__t.html">vec32_t</a> *v, uint32_t data)</td></tr>
<tr class="memdesc:gaf637a5dd4fc2d47514b6cdd1b9341c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">push a value onto the end of the <code>uint32_t</code> vector.  <a href="#gaf637a5dd4fc2d47514b6cdd1b9341c82">More...</a><br /></td></tr>
<tr class="separator:gaf637a5dd4fc2d47514b6cdd1b9341c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafca3e182392e6bef44fbe98c9463a5b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#gafca3e182392e6bef44fbe98c9463a5b7">vec32_reserve</a> (<a class="el" href="structvec32__t.html">vec32_t</a> *v, size_t size)</td></tr>
<tr class="memdesc:gafca3e182392e6bef44fbe98c9463a5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserves the given amount of space for adding new elements.  <a href="#gafca3e182392e6bef44fbe98c9463a5b7">More...</a><br /></td></tr>
<tr class="separator:gafca3e182392e6bef44fbe98c9463a5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf61b2174c5442e8e0c3141deb300a48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#gaaf61b2174c5442e8e0c3141deb300a48">vec32_clear</a> (<a class="el" href="structvec32__t.html">vec32_t</a> *v)</td></tr>
<tr class="memdesc:gaaf61b2174c5442e8e0c3141deb300a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes all the elements in a vector.  <a href="#gaaf61b2174c5442e8e0c3141deb300a48">More...</a><br /></td></tr>
<tr class="separator:gaaf61b2174c5442e8e0c3141deb300a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501c08c5ef1ac66d18f1b49e3cbe1907"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#ga501c08c5ef1ac66d18f1b49e3cbe1907">vec32_index</a> (const <a class="el" href="structvec32__t.html">vec32_t</a> *v, uint32_t data)</td></tr>
<tr class="memdesc:ga501c08c5ef1ac66d18f1b49e3cbe1907"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform reverse lookup on vector  <a href="#ga501c08c5ef1ac66d18f1b49e3cbe1907">More...</a><br /></td></tr>
<tr class="separator:ga501c08c5ef1ac66d18f1b49e3cbe1907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0bc87eea6742431cf8f684e53aae55d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#gae0bc87eea6742431cf8f684e53aae55d">vec32_lsearch</a> (const <a class="el" href="structvec32__t.html">vec32_t</a> *v, void *data, <a class="el" href="group__vec32.html#ga097a00634a6c3e0ffc940a66cdb4372b">vec32_cmp</a> cmp)</td></tr>
<tr class="memdesc:gae0bc87eea6742431cf8f684e53aae55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a linear search on the vector.  <a href="#gae0bc87eea6742431cf8f684e53aae55d">More...</a><br /></td></tr>
<tr class="separator:gae0bc87eea6742431cf8f684e53aae55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac998930271d887cbea7e373df8a8fc1a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#gac998930271d887cbea7e373df8a8fc1a">vec32_bsearch</a> (const <a class="el" href="structvec32__t.html">vec32_t</a> *v, void *data, <a class="el" href="group__vec32.html#ga097a00634a6c3e0ffc940a66cdb4372b">vec32_cmp</a> cmp)</td></tr>
<tr class="memdesc:gac998930271d887cbea7e373df8a8fc1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a binary search on the vector.  <a href="#gac998930271d887cbea7e373df8a8fc1a">More...</a><br /></td></tr>
<tr class="separator:gac998930271d887cbea7e373df8a8fc1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf69a97655fb0fb7c4fbae95afe917712"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#gaf69a97655fb0fb7c4fbae95afe917712">vec32_sort</a> (<a class="el" href="structvec32__t.html">vec32_t</a> *v, <a class="el" href="group__vec32.html#ga097a00634a6c3e0ffc940a66cdb4372b">vec32_cmp</a> cmp)</td></tr>
<tr class="memdesc:gaf69a97655fb0fb7c4fbae95afe917712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the vector.  <a href="#gaf69a97655fb0fb7c4fbae95afe917712">More...</a><br /></td></tr>
<tr class="separator:gaf69a97655fb0fb7c4fbae95afe917712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89637765155d397aae3fdb1102f9a416"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vec32.html#ga89637765155d397aae3fdb1102f9a416">vec32_sum</a> (const <a class="el" href="structvec32__t.html">vec32_t</a> *v)</td></tr>
<tr class="memdesc:ga89637765155d397aae3fdb1102f9a416"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes the sum of the vector.  <a href="#ga89637765155d397aae3fdb1102f9a416">More...</a><br /></td></tr>
<tr class="separator:ga89637765155d397aae3fdb1102f9a416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>data type and functions for handling vectors of <code>uint32_t</code> </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga097a00634a6c3e0ffc940a66cdb4372b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga097a00634a6c3e0ffc940a66cdb4372b">&#9670;&nbsp;</a></span>vec32_cmp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* vec32_cmp) (const void *, const void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison function between two elements. </p>
<p>Functions that have this type can be used as sorting functions with <code><a class="el" href="group__vec32.html#gaf69a97655fb0fb7c4fbae95afe917712" title="Sort the vector. ">vec32_sort()</a></code>, or as comparison functions for <code><a class="el" href="group__vec32.html#gac998930271d887cbea7e373df8a8fc1a" title="Perform a binary search on the vector. ">vec32_bsearch()</a></code>. Functions are expected to behave in the same way as comparison functions for the <code>qsort()</code> function of the standard library. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga8105427fa7427284878c0238a1af6a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8105427fa7427284878c0238a1af6a7b">&#9670;&nbsp;</a></span>vec32_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvec32__t.html">vec32_t</a>* vec32_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>like <code><a class="el" href="group__vec32.html#gaf1a2d7190285201f639b907122247545" title="creates a new vec32_t. ">vec32_new()</a></code>, but allocates with <code>malloc</code>, used to get pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>initial length ov the <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code>. </td></tr>
    <tr><td class="paramname">fill</td><td>what it should be pre-filled with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <code>malloc</code>-allocated <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>unlike <code><a class="el" href="group__vec32.html#gaf1a2d7190285201f639b907122247545" title="creates a new vec32_t. ">vec32_new()</a></code>, which just returns a <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code> that you can keep on the stack, this method returns a pointer to <code>malloc</code>'ed memory, which means that in addition to calling <code><a class="el" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796" title="free()&#39;s the data held inside a vec32_t. ">vec32_free()</a></code> to free the internals, you need to call <code>free()</code> on the pointer itself after you're done using it.</dd></dl>
<h2>Examples</h2>
<p>creating a new empty uint32_t vector</p>
<div class="fragment"><div class="line"><span class="comment">// creates an empty vec32</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> *vec = <a class="code" href="group__vec32.html#ga8105427fa7427284878c0238a1af6a7b">vec32_alloc</a>(0, 0);</div><div class="line"></div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(vec);</div><div class="line">free(vec);</div></div><!-- fragment --><p>creating a pre-filled uint32_t vector</p>
<div class="fragment"><div class="line"><span class="comment">// creates a pre-filled vec32</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> *vec = <a class="code" href="group__vec32.html#ga8105427fa7427284878c0238a1af6a7b">vec32_alloc</a>(10, 99);</div><div class="line"></div><div class="line">assert(<a class="code" href="group__vec32.html#ga67d98adff29507dd90378dbb912eb4a6">vec32_len</a>(vec) == 10);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(vec, 0) == 99);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(vec, 9) == 99);</div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(vec);</div><div class="line">free(vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="gac998930271d887cbea7e373df8a8fc1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac998930271d887cbea7e373df8a8fc1a">&#9670;&nbsp;</a></span>vec32_bsearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vec32_bsearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vec32.html#ga097a00634a6c3e0ffc940a66cdb4372b">vec32_cmp</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a binary search on the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to search </td></tr>
    <tr><td class="paramname">data</td><td>data to search for </td></tr>
    <tr><td class="paramname">cmp</td><td>comparison function between elements and data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an index to the found element, or <code>SIZE_MAX</code></dd></dl>
<p>This function performs a binary search on the sorted vector using <code>cmp</code> as a comparison function. Note that if the vector is not sorted, this function will not work, then you must use <code><a class="el" href="group__vec32.html#gae0bc87eea6742431cf8f684e53aae55d" title="Perform a linear search on the vector. ">vec32_lsearch()</a></code>.</p>
<p>It returns an index to an element that is equal to <code>data</code>.</p>
<p>If <code>NULL</code> is passed as <code>cmp</code>, then the built-in comparison function is used, which assumes that <code>data</code> is a pointer to <code>uint32_t</code>, and compares each element with that.</p>
<h2>Examples</h2>
<p>Find an element in a sorted vector.</p>
<div class="fragment"><div class="line"><span class="comment">// new empty vector</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(0, 0);</div><div class="line"></div><div class="line"><span class="comment">// adds some data to it</span></div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 9);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 5);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 14);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 1);</div><div class="line"></div><div class="line"><span class="comment">// sort vector</span></div><div class="line"><a class="code" href="group__vec32.html#gaf69a97655fb0fb7c4fbae95afe917712">vec32_sort</a>(&amp;vec, NULL);</div><div class="line"></div><div class="line"><span class="comment">// bsearch only works for sorted vectors, so sort it</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 0) == 1);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 1) == 5);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 2) == 9);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 3) == 14);</div><div class="line"></div><div class="line"><span class="comment">// find &#39;9&#39;</span></div><div class="line">uint32_t target = 9;</div><div class="line">assert(<a class="code" href="group__vec32.html#gac998930271d887cbea7e373df8a8fc1a">vec32_bsearch</a>(&amp;vec, &amp;target, NULL) == 2);</div><div class="line"></div><div class="line"><span class="comment">// find an element that doesn&#39;t exist</span></div><div class="line">target = 0;</div><div class="line">assert(<a class="code" href="group__vec32.html#gac998930271d887cbea7e373df8a8fc1a">vec32_bsearch</a>(&amp;vec, &amp;target, NULL) == SIZE_MAX);</div><div class="line"></div><div class="line"><span class="comment">// release</span></div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="gaaf61b2174c5442e8e0c3141deb300a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf61b2174c5442e8e0c3141deb300a48">&#9670;&nbsp;</a></span>vec32_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vec32_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>removes all the elements in a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector to clear </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>internally, this resets the vector's size to 0, but it does not shrink the array used to hold the data. if you want to shrink the container, you can call <code><a class="el" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796" title="free()&#39;s the data held inside a vec32_t. ">vec32_free()</a></code> on it and make a new vector with <code><a class="el" href="group__vec32.html#gaf1a2d7190285201f639b907122247545" title="creates a new vec32_t. ">vec32_new()</a></code>.</dd></dl>
<h2>Examples</h2>
<p>clear pre-initialized vector</p>
<div class="fragment"><div class="line"><span class="comment">// allocate new pre-initialized vector</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(15, 9);</div><div class="line"></div><div class="line"><span class="comment">// forget all elements in vector</span></div><div class="line"><a class="code" href="group__vec32.html#gaaf61b2174c5442e8e0c3141deb300a48">vec32_clear</a>(&amp;vec);</div><div class="line"></div><div class="line"><span class="comment">// check</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga67d98adff29507dd90378dbb912eb4a6">vec32_len</a>(&amp;vec) == 0);</div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3f86a12d44f57c1b5729aebad12dc796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f86a12d44f57c1b5729aebad12dc796">&#9670;&nbsp;</a></span>vec32_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vec32_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>free()</code>'s the data held inside a <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector that will have it's data released. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>this function only releases the data held inside a <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code>, not the <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code> itself. if the <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code> has been produced by <code><a class="el" href="group__vec32.html#ga8105427fa7427284878c0238a1af6a7b" title="like vec32_new(), but allocates with malloc, used to get pointer. ">vec32_alloc()</a></code>, <code>free()</code> must also be called on it to release the structure itself.</dd></dl>
<h2>Examples</h2>
<p>freeing a vector on the stack</p>
<div class="fragment"><div class="line"><span class="comment">// allocate vector on the stack</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(0, 0);</div><div class="line"></div><div class="line"><span class="comment">// free vector contents</span></div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --><p>freeing a vector on the heap</p>
<div class="fragment"><div class="line"><span class="comment">// allocate new vector on the heap</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> *vec = <a class="code" href="group__vec32.html#ga8105427fa7427284878c0238a1af6a7b">vec32_alloc</a>(0, 0);</div><div class="line"></div><div class="line"><span class="comment">// free vector contents</span></div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(vec);</div><div class="line"></div><div class="line"><span class="comment">// free vector itself</span></div><div class="line">free(vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga852aee55c3f73da78fc057a2ec82ffb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga852aee55c3f73da78fc057a2ec82ffb5">&#9670;&nbsp;</a></span>vec32_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vec32_get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gets an element of the <code>uint32_t</code> vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><code>uint32_t</code> vector on which to operate </td></tr>
    <tr><td class="paramname">pos</td><td>which element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element at <code>pos</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this method does not check if the given <code>pos</code> is a legal position inside the vector, accessing <code>pos</code> outside the length of the vector may lead to undefined behaviour.</dd></dl>
<h2>Examples</h2>
<p>get elements from a pre-filled vec32</p>
<div class="fragment"><div class="line"><span class="comment">// creates a pre-filled vec32</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(10, 99);</div><div class="line"></div><div class="line"><span class="comment">// gets the first and last element</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 0) == 99);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 9) == 99);</div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --><p>get elements from a vec32 that has been <code><a class="el" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82" title="push a value onto the end of the uint32_t vector. ">vec32_push()</a></code>ed to</p>
<div class="fragment"><div class="line"><span class="comment">// creates a new empty vec32</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(0, 0);</div><div class="line"></div><div class="line"><span class="comment">// push some data into it</span></div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 15);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 95);</div><div class="line"></div><div class="line"><span class="comment">// check values</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 0) == 15);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 1) == 95);</div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga501c08c5ef1ac66d18f1b49e3cbe1907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga501c08c5ef1ac66d18f1b49e3cbe1907">&#9670;&nbsp;</a></span>vec32_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vec32_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform reverse lookup on vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to perform lookup in </td></tr>
    <tr><td class="paramname">data</td><td>element to look up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of <code>data</code> in <code>v</code>, or <code>SIZE_MAX</code> if <code>data</code> does not exist in <code>v</code>.</dd></dl>
<p>for a given vector <code>v</code> and element <code>data</code>, searches the vector for occurences of <code>data</code>, returning the index of the first occurence or <code>SIZE_MAX</code> to indicate that the element does not exist.</p>
<h2>Examples</h2>
<div class="fragment"><div class="line"><span class="comment">// allocates new vector</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(0, 0);</div><div class="line"></div><div class="line"><span class="comment">// adds some data to vec</span></div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 16);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 19);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 23);</div><div class="line"></div><div class="line"><span class="comment">// find index of some elements in vector</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga501c08c5ef1ac66d18f1b49e3cbe1907">vec32_index</a>(&amp;vec, 16) == 0);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga501c08c5ef1ac66d18f1b49e3cbe1907">vec32_index</a>(&amp;vec, 19) == 1);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga501c08c5ef1ac66d18f1b49e3cbe1907">vec32_index</a>(&amp;vec, 23) == 2);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga501c08c5ef1ac66d18f1b49e3cbe1907">vec32_index</a>(&amp;vec, 20) == SIZE_MAX);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga67d98adff29507dd90378dbb912eb4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67d98adff29507dd90378dbb912eb4a6">&#9670;&nbsp;</a></span>vec32_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vec32_len </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the length of a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to get length of </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>length of <code>v</code></dd></dl>
<h2>Examples</h2>
<p>get length of pre-filled vector</p>
<div class="fragment"><div class="line"><span class="comment">// creates a vec with length 2</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(2, 0);</div><div class="line"></div><div class="line"><span class="comment">// checks length</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga67d98adff29507dd90378dbb912eb4a6">vec32_len</a>(&amp;vec) == 2);</div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="gae0bc87eea6742431cf8f684e53aae55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0bc87eea6742431cf8f684e53aae55d">&#9670;&nbsp;</a></span>vec32_lsearch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vec32_lsearch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vec32.html#ga097a00634a6c3e0ffc940a66cdb4372b">vec32_cmp</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform a linear search on the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to search </td></tr>
    <tr><td class="paramname">data</td><td>data to search for </td></tr>
    <tr><td class="paramname">cmp</td><td>comparison function between elements and data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an index to the found element, or <code>SIZE_MAX</code></dd></dl>
<p>This function performs a linear search on the vector, meaning that it will traverse it in order and compare all elements to <code>data</code> using <code>cmp</code>, a comparison function supplied by the user. Returns the index of the first element for which the comparison function indicates that the elements are equal.</p>
<p>If <code>NULL</code> is passed as <code>cmp</code>, then the built-in comparison function is used, which assumes that <code>data</code> is a pointer to <code>uint32_t</code>, and compares each element with that.</p>
<h2>Examples</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="gaf1a2d7190285201f639b907122247545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1a2d7190285201f639b907122247545">&#9670;&nbsp;</a></span>vec32_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvec32__t.html">vec32_t</a> vec32_new </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creates a new <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>length of the vec32 </td></tr>
    <tr><td class="paramname">fill</td><td>what the vec32 should initially be filled with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code> with the given length and filled with the given values.</dd></dl>
<h2>Examples</h2>
<p>creating a new empty uint32_t vector</p>
<div class="fragment"><div class="line"><span class="comment">// creates an empty vec32</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(0, 0);</div><div class="line"></div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --><p>creating a pre-filled uint32_t vector</p>
<div class="fragment"><div class="line"><span class="comment">// creates a pre-filled vec32</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(10, 99);</div><div class="line"></div><div class="line">assert(<a class="code" href="group__vec32.html#ga67d98adff29507dd90378dbb912eb4a6">vec32_len</a>(&amp;vec) == 10);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 0) == 99);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 9) == 99);</div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf637a5dd4fc2d47514b6cdd1b9341c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf637a5dd4fc2d47514b6cdd1b9341c82">&#9670;&nbsp;</a></span>vec32_push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vec32_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>push a value onto the end of the <code>uint32_t</code> vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to push onto </td></tr>
    <tr><td class="paramname">data</td><td><code>uint32_t</code> to push onto the end </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new size of the vector </dd></dl>
<dl class="section note"><dt>Note</dt><dd>if you know that you will push a large amount of data onto the vector, you may want to call <code><a class="el" href="group__vec32.html#gafca3e182392e6bef44fbe98c9463a5b7" title="reserves the given amount of space for adding new elements. ">vec32_reserve()</a></code> to make space for it.</dd></dl>
<h2>Examples</h2>
<p>push some data onto the end of an empty vector</p>
<div class="fragment"><div class="line"><span class="comment">// creates a new empty vector</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(0, 0);</div><div class="line"></div><div class="line"><span class="comment">// push some values onto the end</span></div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 77);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 99);</div><div class="line"></div><div class="line"><span class="comment">// make sure the values are there</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga67d98adff29507dd90378dbb912eb4a6">vec32_len</a>(&amp;vec) == 2);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 0) == 77);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 1) == 99);</div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="gafca3e182392e6bef44fbe98c9463a5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafca3e182392e6bef44fbe98c9463a5b7">&#9670;&nbsp;</a></span>vec32_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vec32_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reserves the given amount of space for adding new elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector to reserve space for </td></tr>
    <tr><td class="paramname">size</td><td>how much additional space to reserve</td></tr>
  </table>
  </dd>
</dl>
<p>when adding large amount of data to a vector, and when the size of the data is known in advance, this method can be used to reserve space for the data to add to prevent multiple reallocations of the data.</p>
<h2>Examples</h2>
<p>reserves some space in vector to add large amounts of data.</p>
<div class="fragment"><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(0, 0);</div><div class="line"></div><div class="line"><span class="comment">// reserve enough space</span></div><div class="line"><span class="keywordtype">size_t</span> data_size = 1000000;</div><div class="line"><a class="code" href="group__vec32.html#gafca3e182392e6bef44fbe98c9463a5b7">vec32_reserve</a>(&amp;vec, data_size);</div><div class="line"></div><div class="line"><span class="comment">// add data</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> cur = 0; cur &lt; data_size; cur++) {</div><div class="line">  <a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 9);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga3b4d78afc51457c7099377c6fbc23052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b4d78afc51457c7099377c6fbc23052">&#9670;&nbsp;</a></span>vec32_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vec32_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets the element at the specified position to <code>data</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><code>uint32_t</code> vector to operate on </td></tr>
    <tr><td class="paramname">pos</td><td>which element to overwrite </td></tr>
    <tr><td class="paramname">data</td><td>new data for the position </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous value at <code>pos</code> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>this method does not check if the given <code>pos</code> is a legal position inside the vector, accessing <code>pos</code> outside the length of the vector may lead to undefined behaviour.</dd></dl>
<h2>Examples</h2>
<p>set elements in a pre-filled <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code></p>
<div class="fragment"><div class="line"><span class="comment">// creates a pre-filled vec32</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(10, 99);</div><div class="line"></div><div class="line"><span class="comment">// returns previous element</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga3b4d78afc51457c7099377c6fbc23052">vec32_set</a>(&amp;vec, 0, 15) == 99);</div><div class="line"></div><div class="line"><span class="comment">// check if set worked</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 0) == 15);</div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --><p>set elements in a <code><a class="el" href="structvec32__t.html" title="vector of uint32_t data type. ">vec32_t</a></code> that has been pushed to</p>
<div class="fragment"><div class="line"><span class="comment">// creates a new empty vec32</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(0, 0);</div><div class="line"></div><div class="line"><span class="comment">// push some data into it</span></div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 15);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 95);</div><div class="line"></div><div class="line"><span class="comment">// set new values</span></div><div class="line"><a class="code" href="group__vec32.html#ga3b4d78afc51457c7099377c6fbc23052">vec32_set</a>(&amp;vec, 0, 100);</div><div class="line"><a class="code" href="group__vec32.html#ga3b4d78afc51457c7099377c6fbc23052">vec32_set</a>(&amp;vec, 1, 200);</div><div class="line"></div><div class="line"><span class="comment">// check values</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 0) == 100);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 1) == 200);</div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="gaf69a97655fb0fb7c4fbae95afe917712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf69a97655fb0fb7c4fbae95afe917712">&#9670;&nbsp;</a></span>vec32_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vec32_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__vec32.html#ga097a00634a6c3e0ffc940a66cdb4372b">vec32_cmp</a>&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort the vector. </p>
<p>Sorts the vector in-place using the provided comparison function. If <code>NULL</code> is passed as comparison function, then falls back to a built-in comparison function that sorts the numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to sort. </td></tr>
    <tr><td class="paramname">cmp</td><td>comparison function between elements.</td></tr>
  </table>
  </dd>
</dl>
<h2>Examples</h2>
<div class="fragment"><div class="line"><span class="comment">// new empty vector</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(0, 0);</div><div class="line"></div><div class="line"><span class="comment">// adds some data to it</span></div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 9);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 5);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 14);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 1);</div><div class="line"></div><div class="line"><span class="comment">// sort vector</span></div><div class="line"><a class="code" href="group__vec32.html#gaf69a97655fb0fb7c4fbae95afe917712">vec32_sort</a>(&amp;vec, NULL);</div><div class="line"></div><div class="line"><span class="comment">// check that it&#39;s sorted</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 0) == 1);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 1) == 5);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 2) == 9);</div><div class="line">assert(<a class="code" href="group__vec32.html#ga852aee55c3f73da78fc057a2ec82ffb5">vec32_get</a>(&amp;vec, 3) == 14);</div><div class="line"></div><div class="line"><span class="comment">// release</span></div><div class="line"><a class="code" href="group__vec32.html#ga3f86a12d44f57c1b5729aebad12dc796">vec32_free</a>(&amp;vec);</div></div><!-- fragment --> 
</div>
</div>
<a id="ga89637765155d397aae3fdb1102f9a416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga89637765155d397aae3fdb1102f9a416">&#9670;&nbsp;</a></span>vec32_sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vec32_sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvec32__t.html">vec32_t</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes the sum of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector with numbers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of all elements in <code>v</code></dd></dl>
<h2>Examples</h2>
<p>compute sum of some numbers</p>
<div class="fragment"><div class="line"><span class="comment">// allocate new pre-initialized vector</span></div><div class="line"><a class="code" href="structvec32__t.html">vec32_t</a> vec = <a class="code" href="group__vec32.html#gaf1a2d7190285201f639b907122247545">vec32_new</a>(10, 8);</div><div class="line"></div><div class="line"><span class="comment">// add more values to vector</span></div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 77);</div><div class="line"><a class="code" href="group__vec32.html#gaf637a5dd4fc2d47514b6cdd1b9341c82">vec32_push</a>(&amp;vec, 10);</div><div class="line"></div><div class="line"><span class="comment">// compute sum of elements</span></div><div class="line">assert(<a class="code" href="group__vec32.html#ga89637765155d397aae3fdb1102f9a416">vec32_sum</a>(&amp;vec) == 167);</div></div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
